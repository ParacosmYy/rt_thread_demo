正在一步步复刻源码中
参考野火内核
...
- DAY1 复刻线程1和线程2切换的时候出现了两个问题，问题1：忘记了给stack_frame赋值stk，导致stack_frame后面的寄存器的初始值赋值了没有用，一直卡在了bx lr的至零上，无法进行线程切换。问题2：忘记了在线程切换的时候开启调度器的使用，导致一直运行的是线程1，无法运行线程2
- DAY2 今天增添对象容器的时候又弄明白了一些东西，第一个是对象可以理解是开辟了很多个链表，每个链表是独属于一个对象的，比如rt中有着线程，定时器，信号量，邮箱等各种对象，每个对象都是一个独一无二的的链表，假如有了线程1和线程2，则将这两个线程分别挂在线程对象表头后面，假如有了定时器1和定时器2，则分别将这两个定时器挂载到定时器对象表头的后面。第二个学到的点是在线程块初始化的时候，先进行了对象的初始化，但是传入的参数确实线程块的参数，所以直接强制将线程块强转为对象类型的（因为对象类型所包含的成员变量均是线程控制块的成员变量）
- DAY3，4 空闲线程和阻塞延时的实现：idle线程插入到就绪列表的max-1的位置，也就是尾巴，优先级最低的位置。目前的idle_entry函数中只是增添了ctr++，其余的还未曾添加，然后irq文件中存储了两个中断服务函数（开关中断，并且记录nest的次数）。在clock文件中，目前只有让线程延时函数自减的操作，并启动调度器切换线程。在main函数中，多了系统定时器中断，GS_TICK_PER_SECOND为100，即每秒钟中断100次。本次复刻遇到的问题：1.忘记了初始化空闲线程，这会导致在进行线程1和线程2切换完后会进入到空闲线程，但空闲线程并没有对应的sp指针，因此会引起HF错误，导致线程12卡死，一直拉高。
-  DAY 5,6,7 今天彻底完成了多优先级的实现，真是小问题一个个改，一个个排查。主要是卡死在了两个问题，特此记录一下，第一个问题是：在kservice.c文件中，我的ffs函数写的与书上的不符，书上是查表法，置1，我是自己写的判断与1的结果来检查，问题就出现在查表中比如说第二位是1，我返回值就是3，但是我自己写的确实返回2，这导致了在进行位掩码的判断中出现了问题，一直都是下一个即将要运行优先级3的线程2却在ready_priority变量中显示2，这就导致了我的线程1一直在被迫运行，无法切换到线程2。还有一个问题出现在了clock.c中，在我仿真进行dubug的时候，我延时200m秒后无法进行线程跳转，会卡死在硬件中断上，我怀疑的是我的tick判断不对，结果又去看我的tick变量，发现tick变量一直没有自增，但是这个变量却跟我线程切换没有关系，即使他不自增，那他就等于没有延时，也能进行线程跳转，结果看了很久才发现，原来是thread->number_mask没有弄对，我只想了他的current_priority,所以一直无法对的上位掩码，导致线程一直搜索不到就绪的线程。
- DAY 8,9,10,11,12,13,14,15 今天完成了定时器的实现，能够通过定时器实现计时延时等操作，然而本章节的复刻仍出现了一些问题，在此记录一下。我本次定义了1和2和3三个线程，分别设置了2，3，4的优先级，延时分别是3tick，2tick和4tick，在我第一次刚写完后进行dubug仿真波形，发现只有线程1的波形是正常的，线程2和3都没有波形，然后就去看了current_priority变量，发现在进行延时跳转到suspend函数的时候，这个变量并没有改变，仍为2，这就说明这个线程从就绪态到挂载态的时候位掩码并没有彻底的消除，我进而追随suspend函数，在里面我看到了我的位掩码取反的语句，所以我在往上看，看到了对应的remove函数，跳转进去发现remove函数中的节点删除语句没有写对，最后写了个p->prev = p->next = new_node 直接将指针指向错误了，导致链表中断。因此在isempty函数中检查链表是否为空即l->next == l 返回的是一个0，进而无法进行位掩码修改。在调整完这个错误后，我又进行了仿真波形测试，发现都正常了。
- DAY 16 完成了时间片的实现，终于可以使多个线程在统一优先级下同时运行相互不影响了。记录问题：底层的链表插入有问题，之前一直没有发现，本次运行仿真波形的时候，线程1能一直运行，这个是因为优先级最高，但是线程2和线程3处于同一优先级下却只能跑一个线程，将线程2或者3的优先级改变后就都能跑。但是我仿真的时候是只有线程1和线程3在进行运作，线程2死活进不去，我就先去观察了一下位掩码，发现线程3运作完后，位掩码会变成线程1的状态，即没有回到线程2，直接跳过了线程2，百思不得其解下，我观察了priority_table这个结构体数组，突然发现下标为0的next竟然不等于下标为1的prev，这就很奇怪了，我又去看了下代码，发现我之前的链表插入代码有问题，我之前是将新节点的next指针指向原链表的头节点，这样就导致了链表中断，我现在改成了将新节点的next指针指向原链表的尾节点，这样就不会出现链表中断了。实话说这犯了一个太蠢的问题，之前没有发现的原因是线程给的不够多，导致没有观察出来...
- DAY 17 完成了GSthread在stm32f407ZGT6的移植，并且创建了三个线程，线程中有thread_delay，实现了led的翻转，并且三个线程互不影响，已通过验证。记录本次遇到的问题（移植方面）：1.stm32的it.c里面的pendsv和system-timer的终端服务函数要屏蔽掉，因为在gsthread中实现了对应的两个中断。2.在仿真中，使用软件仿真无法观察flag的波形，会遇到地址错误？导致仿真只能一条条代码进行读取，改了个remap，也没解决，先放这里了。3.CMSIS中没有core.c的文件，只有.h的文件，可以通过core_cm4.h将之前的arm4.h文件替换掉。